@file:Suppress("LocalVariableName")
fun test(log : (String) -> Unit)
{
    val functions = arrayOf(::testConfig,
        ::exProp1, ::exProp2, ::exProp3,
        ::exModal1, ::exModal2, ::exModal3,
        ::exPred1, ::exPred2, ::exPred3, ::exPred4,
        ::exModal4, ::exModal5, ::exModal6,
        ::exModal7, ::exModal8, ::exModal9,
        ::exModal10
    )

    for (function in functions)
        function(log)
}

private fun testConfig(log : (String) -> Unit)
{
    val configString = """
        logic = 'PropositionalLogic'
        vars = 'P,Q,R'
        premise1 = 'P ‚äÉ Q'
        premise2 = 'R ‚äÉ Q'
        conclusion = '(P ‚à® R) ‚äÉ Q'
    """

    val problem = Problem.fromConfig(configString)
    val proof = problem.prove()
    log("${proof}\n\n")
}

private fun exProp1(log : (String) -> Unit)
{
    // { P ‚äÉ Q, R ‚äÉ Q } ‚ä¢ { (P ‚à® R) ‚äÉ Q }
    val logic = PropositionalLogic()
    val formulaFactory = FormulaFactory(logic)
    val P = formulaFactory.newAtom("P")
    val Q = formulaFactory.newAtom("Q")
    val R = formulaFactory.newAtom("R")

    val premise1 = formulaFactory.new(P, Operation.Imply, Q)
    val premise2 = formulaFactory.new(R, Operation.Imply, Q)
    val conclusion = formulaFactory.new(formulaFactory.new(P, Operation.Or, R), Operation.Imply, Q)
    val proof = Problem(logic, listOf(premise1, premise2), conclusion).prove()
    log("PROVE: { $premise1, $premise2 } ‚ä¢ { $conclusion }\n$proof\n\n")
}

private fun exProp2(log : (String) -> Unit)
{
    // { P ‚äÉ (Q ‚à® R), P ‚àß ¬¨R } ‚ä¢ { Q }
    val logic = PropositionalLogic()
    val formulaFactory = FormulaFactory(logic)
    val P = formulaFactory.newAtom("P")
    val Q = formulaFactory.newAtom("Q")
    val R = formulaFactory.newAtom("R")

    val premise1 = formulaFactory.new(P, Operation.Imply, formulaFactory.new(Q, Operation.Or, R))
    val premise2 = formulaFactory.new(P, Operation.And, formulaFactory.new(Operation.Non, R))
    val proof = Problem(logic, listOf(premise1, premise2), Q).prove()
    log("PROVE: { $premise1, $premise2 } ‚ä¢ { $Q }\n$proof\n\n")
}

private fun exProp3(log : (String) -> Unit)
{
    // { P ‚à® (Q ‚àß R) } ‚ä¢ { (P ‚à® Q) ‚àß (P ‚à® R) }
    val logic = PropositionalLogic()
    val formulaFactory = FormulaFactory(logic)
    val P = formulaFactory.newAtom("P")
    val Q = formulaFactory.newAtom("Q")
    val R = formulaFactory.newAtom("R")

    val premise1 = formulaFactory.new(P, Operation.Or, formulaFactory.new(Q, Operation.And, R))
    val conclusion = formulaFactory.new(formulaFactory.new(P, Operation.Or, Q), Operation.And, formulaFactory.new(P, Operation.Or, R))
    val proof = Problem(logic, listOf(premise1), conclusion).prove()
    log("PROVE: { $premise1 } ‚ä¢ { $conclusion }\n$proof\n\n")
}

private fun exModal1(log : (String) -> Unit)
{
    // ‚ä¢‚Çñ { ‚óáP ‚â° ¬¨‚ñ°¬¨P }
    val logic = FirstOrderModalLogic(ModalLogicType.K)
    val formulaFactory = FormulaFactory(logic)
    val P = formulaFactory.newAtom("P")

    val statement = formulaFactory.new(
        formulaFactory.new(Operation.Possible(), P), Operation.BiImply,
        formulaFactory.new(Operation.Non, formulaFactory.new(Operation.Necessary(), formulaFactory.new(Operation.Non, P))))
    val proof = Problem(logic, listOf(), statement).prove()
    log("PROVE: ‚ä¢‚Çñ { $statement }\n$proof\n\n")
}

private fun exModal2(log : (String) -> Unit)
{
    // ‚ä¢‚Çñ { ‚óá(P ‚à® Q) ‚äÉ (‚óáP ‚à® ‚óáQ) }
    val logic = FirstOrderModalLogic(ModalLogicType.K)
    val formulaFactory = FormulaFactory(logic)
    val P = formulaFactory.newAtom("P")
    val Q = formulaFactory.newAtom("Q")

    val statement = formulaFactory.new(
        formulaFactory.new(Operation.Possible(), formulaFactory.new(P, Operation.Or, Q)), Operation.Imply,
        formulaFactory.new(formulaFactory.new(Operation.Possible(), P), Operation.Or, formulaFactory.new(Operation.Possible(), Q)))
    val proof = Problem(logic, listOf(), statement).prove()
    log("PROVE: ‚ä¢‚Çñ { $statement }\n$proof\n\n")
}

private fun exModal3(log : (String) -> Unit)
{
    // { ‚ñ°(P ‚äÉ Q) } ‚ä¢‚Çñ { ‚óáP ‚äÉ ‚óáQ }
    val logic = FirstOrderModalLogic(ModalLogicType.K)
    val formulaFactory = FormulaFactory(logic)
    val P = formulaFactory.newAtom("P")
    val Q = formulaFactory.newAtom("Q")

    val premise = formulaFactory.new(Operation.Necessary(), formulaFactory.new(P, Operation.Imply, Q))
    val conclusion = formulaFactory.new(formulaFactory.new(Operation.Possible(), P), Operation.Imply, formulaFactory.new(Operation.Possible(), Q))
    val proof = Problem(logic, listOf(premise), conclusion).prove()
    log("PROVE: { $premise } ‚ä¢‚Çñ { $conclusion }\n$proof\n\n")
}

private fun exModal4(log : (String) -> Unit)
{
    // { ‚ñ°(‚óáP ‚àß ‚óáQ) } ‚ä¢‚Çñ { ‚ñ°‚óáQ }
    val logic = FirstOrderModalLogic(ModalLogicType.K)
    val formulaFactory = FormulaFactory(logic)
    val P = formulaFactory.newAtom("P")
    val Q = formulaFactory.newAtom("Q")

    val premise = formulaFactory.new(Operation.Necessary(), formulaFactory.new(
        formulaFactory.new(Operation.Possible(), P), Operation.And, formulaFactory.new(Operation.Possible(), Q)))
    val conclusion = formulaFactory.new(Operation.Necessary(), formulaFactory.new(Operation.Possible(), Q))
    val proof = Problem(logic, listOf(premise), conclusion).prove()
    log("PROVE: { $premise } ‚ä¢‚Çñ { $conclusion }\n$proof\n\n")
}

private fun exModal5(log : (String) -> Unit)
{
    // ‚ä¢·µ¶ { ‚ñ°P ‚à® ‚ñ°Q } ‚â° { ‚ñ°(‚ñ°P ‚à® ‚ñ°Q) }
    val logic = FirstOrderModalLogic(ModalLogicType.B)
    val formulaFactory = FormulaFactory(logic)
    val P = formulaFactory.newAtom("P")
    val Q = formulaFactory.newAtom("Q")

    val statement = formulaFactory.new(
        formulaFactory.new(formulaFactory.new(Operation.Necessary(), P), Operation.Or, formulaFactory.new(Operation.Necessary(), Q)),
        Operation.BiImply, formulaFactory.new(Operation.Necessary(), formulaFactory.new(
            formulaFactory.new(Operation.Necessary(), P), Operation.Or, formulaFactory.new(Operation.Necessary(), Q))))
    val proof = Problem(logic, listOf(), statement).prove()
    log("PROVE: ‚ä¢·µ¶ { $statement }\n$proof\n\n")
}

private fun exModal6(log : (String) -> Unit)
{
    // ‚ä¢‚Çõ‚ÇÖ ‚óáP ‚äÉ ‚óá‚óáP
    val logic = FirstOrderModalLogic(ModalLogicType.S5)
    val formulaFactory = FormulaFactory(logic)
    val P = formulaFactory.newAtom("P")

    val statement = formulaFactory.new(formulaFactory.new(Operation.Possible(), P), Operation.Imply,
        formulaFactory.new(Operation.Possible(), formulaFactory.new(Operation.Possible(), P)))
    val proof = Problem(logic, listOf(), statement).prove()
    log("PROVE: ‚ä¢‚Çõ‚ÇÖ { $statement }\n$proof\n\n")
}

private fun exModal7(log : (String) -> Unit)
{
    // ‚ä¢‚Çõ‚ÇÖ ‚óáP ‚äÉ ‚ñ°‚óáP
    val logic = FirstOrderModalLogic(ModalLogicType.S5)
    val formulaFactory = FormulaFactory(logic)
    val P = formulaFactory.newAtom("P")

    val statement = formulaFactory.new(formulaFactory.new(Operation.Possible(), P), Operation.Imply,
        formulaFactory.new(Operation.Necessary(), formulaFactory.new(Operation.Possible(), P)))
    val proof = Problem(logic, listOf(), statement).prove()
    log("PROVE: ‚ä¢‚Çõ‚ÇÖ { $statement }\n$proof\n\n")
}

private fun exModal8(log : (String) -> Unit)
{
    // ‚ä¢‚Çõ‚ÇÖ ‚ñ°(‚ñ°P ‚äÉ ‚ñ°Q) ‚à® ‚ñ°(‚ñ°Q ‚äÉ ‚ñ°P)
    val logic = FirstOrderModalLogic(ModalLogicType.S5)
    val formulaFactory = FormulaFactory(logic)
    val P = formulaFactory.newAtom("P")
    val Q = formulaFactory.newAtom("Q")

    val statement = formulaFactory.new(formulaFactory.new(Operation.Necessary(),
        formulaFactory.new(formulaFactory.new(Operation.Necessary(), P), Operation.Imply, formulaFactory.new(Operation.Necessary(), Q))),
        Operation.Or, formulaFactory.new(Operation.Necessary(),
        formulaFactory.new(formulaFactory.new(Operation.Necessary(), Q), Operation.Imply, formulaFactory.new(Operation.Necessary(), P))))
    val proof = Problem(logic, listOf(), statement).prove()
    log("PROVE: ‚ä¢‚Çõ‚ÇÖ { $statement }\n$proof\n\n")
}

private fun exModal9(log : (String) -> Unit)
{
    //‚ä¢‚Çñ P ‚äÉ üÑµ‚ìÖP
    val logic = FirstOrderModalLogic(ModalLogicType.K·µó)
    val formulaFactory = FormulaFactory(logic)
    val P = formulaFactory.newAtom("P")

    val statement = formulaFactory.new(P, Operation.Imply, formulaFactory.new(
        Operation.Necessary.InFuture(), formulaFactory.new(Operation.Possible.InPast(), P)))
    val proof = Problem(logic, listOf(), statement).prove()
    log("PROVE: ‚ä¢‚Çñ { $statement }\n$proof\n\n")
}

private fun exModal10(log : (String) -> Unit)
{
    //‚ä¢‚Çô (A‚•ΩB) ‚•Ω (¬¨B‚•Ω¬¨A)
    val logic = FirstOrderModalLogic(ModalLogicType.N)
    val formulaFactory = FormulaFactory(logic)
    val A = formulaFactory.newAtom("A")
    val B = formulaFactory.newAtom("B")

    val statement = formulaFactory.new(
        formulaFactory.new(A, Operation.StrictImply, B), Operation.StrictImply,
        formulaFactory.new(formulaFactory.new(Operation.Non, B), Operation.StrictImply, formulaFactory.new(Operation.Non, A)))
    val proof = Problem(logic, listOf(), statement).prove()
    log("PROVE: ‚ä¢‚Çô { $statement }\n$proof\n\n")
}

private fun exPred1(log : (String) -> Unit)
{
    // { ‚àÄx(Human(x) -> Mortal(x)), Human(Socrates) } ‚ä¢ { Mortal(Socrates) }
    val logic = FirstOrderLogic()
    val formulaFactory = FormulaFactory(logic)
    val x = formulaFactory.newBindingVariable("x")
    val Socrates = formulaFactory.newUnboundedVariable("Socrates")
    val Human = formulaFactory.newAtom("Human")
    val Mortal = formulaFactory.newAtom(("Mortal"))

    val premise1 = formulaFactory.new(Operation.ForAll(x), formulaFactory.new(Human(x), Operation.Imply, Mortal(x)))
    val premise2 = Human(Socrates)
    val conclusion = Mortal(Socrates)
    val proof = Problem(logic, listOf(premise1, premise2), conclusion).prove()
    log("PROVE: { $premise1, $premise2 } ‚ä¢ { $conclusion }\n$proof\n\n")
}

private fun exPred2(log : (String) -> Unit)
{
    // { ‚àÄx(Px ‚äÉ ‚àÉy.Sxy) } ‚ä¢ { ‚àÄx.‚àÉy(Px ‚äÉ Sxy ) }
    val logic = FirstOrderLogic()
    val formulaFactory = FormulaFactory(logic)
    val x = formulaFactory.newBindingVariable("x")
    val y = formulaFactory.newBindingVariable("y")
    val P = formulaFactory.newAtom("P")
    val S = formulaFactory.newAtom("S")

    val premise = formulaFactory.new(Operation.ForAll(x), formulaFactory.new(P(x), Operation.Imply, formulaFactory.new(Operation.Exists(y), S(x, y))))
    val conclusion = formulaFactory.new(Operation.ForAll(x), formulaFactory.new(Operation.Exists(y), formulaFactory.new(P(x), Operation.Imply, S(x, y))))
    val proof = Problem(logic, listOf(premise), conclusion).prove()
    log("PROVE: { $premise } ‚ä¢ { $conclusion }\n$proof\n\n")
}

private fun exPred3(log : (String) -> Unit)
{
    // { ‚àÉx.¬¨‚àÉy.Sxy } ‚ä¢ { ¬¨‚àÉx.‚àÄy.Sxy }
    val logic = FirstOrderLogic()
    val formulaFactory = FormulaFactory(logic)
    val x = formulaFactory.newBindingVariable("x")
    val y = formulaFactory.newBindingVariable("y")
    val S = formulaFactory.newAtom("S")

    val premise = formulaFactory.new(Operation.Exists(x), formulaFactory.new(Operation.Non, formulaFactory.new(Operation.Exists(y), S(x, y))))
    val conclusion = formulaFactory.new(Operation.Non, formulaFactory.new(Operation.Exists(x), formulaFactory.new(Operation.ForAll(y), S(x, y))))
    val proof = Problem(logic, listOf(premise), conclusion).prove()
    log("PROVE: { $premise } ‚ä¢ { $conclusion }\n$proof\n\n")
}

private fun exPred4(log : (String) -> Unit)
{
    // ‚ä¢ { ‚àÉx.‚àÉy.Pxy ‚â° ‚àÉx.‚àÉy.Pyx }
    val logic = FirstOrderLogic()
    val formulaFactory = FormulaFactory(logic)
    val x = formulaFactory.newBindingVariable("x")
    val y = formulaFactory.newBindingVariable("y")
    val P = formulaFactory.newAtom("P")

    x.couldBecomeEquivalentTo(y)
    y.couldBecomeEquivalentTo(x)

    val statement = formulaFactory.new(
        formulaFactory.new(Operation.Exists(x), formulaFactory.new(Operation.Exists(y), P(x, y))), Operation.BiImply,
        formulaFactory.new(Operation.Exists(x), formulaFactory.new(Operation.Exists(y), P(y, x))))
    val proof = Problem(logic, listOf(), statement).prove()
    log("PROVE: ‚ä¢ { $statement }\n$proof\n\n")
}
